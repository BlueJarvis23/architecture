Phase_1:
    I noticed that in the phase_1 function that a value was saved in an address was saved in the 'si' register. The register was used in the string not 
        equal function so I printed out the contents of the address in the following way. 

        (gdb) x/100cb $rsi
        0x401b88:   86 'V'  101 'e' 114 'r' 98 'b'  111 'o' 115 's' 105 'i' 116 't'
        0x401b90:   121 'y' 32 ' '  108 'l' 101 'e' 97 'a'  100 'd' 115 's' 32 ' '
        0x401b98:   116 't' 111 'o' 32 ' '  117 'u' 110 'n' 99 'c'  108 'l' 101 'e'
        0x401ba0:   97 'a'  114 'r' 44 ','  32 ' '  105 'i' 110 'n' 97 'a'  114 'r'
        0x401ba8:   116 't' 105 'i' 99 'c'  117 'u' 108 'l' 97 'a'  116 't' 101 'e'
        0x401bb0:   32 ' '  116 't' 104 'h' 105 'i' 110 'n' 103 'g' 115 's' 46 '.'
        0x401bb8:   0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'
        0x401bc0:   92 '\\' 17 '\021'   64 '@'  0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'
        0x401bc8:   99 'c'  17 '\021'   64 '@'  0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'
        0x401bd0:   85 'U'  17 '\021'   64 '@'  0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'
        0x401bd8:   78 'N'  17 '\021'   64 '@'  0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'
        0x401be0:   71 'G'  17 '\021'   64 '@'  0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'
        0x401be8:   64 '@'  17 '\021'   64 '@'  0 '\000'

        (gdb) x/1sb 0x401b88
        0x401b88:   "Verbosity leads to unclear, inarticulate things."
        
Phase_2
    After an accidental explosion of a bomb ('dis' will disable all breakpoints) I found that read_six_numbers just checked input from for 6 integers
        separated by a space character. If input is of this form then I arrived at instruction 0x4011d8. 

              0x00000000004011d6 <+40>:    mov    (%rbx),%eax
           => 0x00000000004011d8 <+42>:    cmp    0xc(%rbx),%eax
              0x00000000004011db <+45>:    je     0x4011e2 <phase_2+52>
              0x00000000004011dd <+47>:    callq  0x40153e <explode_bomb>

        This part is in a loop that looks at all of the numbers comparing them with the number contained in the address in rbx+0xc.

        (gdb) x $rbx +0xc 
        0x7fffffffde64: 0x00000005

        By some trial and error it was found that the sequence needed to be '3 4 5 3 4 5'

Phase_3
    After phase_2 and understanding that the instruction 'callq  0x400b28 <__isoc99_sscanf@plt>' checked for the correct number of terms to be input
        as the phase response, I learned that the sscanf function placed a value in $rax that corresponded with the number of integers found.
        This value is then compared with one less than the expected value from the function.

        0x0000000000401111 <+24>:    callq  0x400b28 <__isoc99_sscanf@plt>
        0x0000000000401116 <+29>:    cmp    $0x1,%eax

        In the case of phase_3 the input needed is 2 numbers. After an input of 2 numbers the address 0x401120 can be reached.        

        It was noticed that as address 0x40112b was a switch statement. Upon examination of the jumpTable we notice that only input of zero added
            0x386 to our value. This number then went through a series of adds and subtracts and comparted itself equal to the the second input.
            After the adds and subtracks the value left is 348. This was then used as our second input.

        0 348

Phase_4
    We noticed that phase_4 was calling a func4. func4 we noticed was a recursive function that computed the fibonacci sequence. This basic ideas if 
        shown in the below python code.

        def fib(x):
            if x == 1:
                return 1
            elif x == 0: 
                return 0
            return fib(x-1) + fib(x-2)

        Next we found what number phase_4 wanted us to recieve from func4 and found that we needed to put in a 22 to get the result that was needed.

Phase_5
    This phase wanted a string that 6 characters in length. The characters were then masked to use only the first 4 bits (lease significant) as a key 
        to an array with mapped values 1 - 16. The six mapped values needed to add up to 0x3e = 62. When we first started the six character string 
        we used was dallin. This gave us a result of 66. This was close enough to get us started and by looking at the array we found out that if 
        we changed dallin to mallin we would get the correct result.

        (gdb) x/16xw 0x401c00
        0x401c00 <array.3294>:  0x00000002      0x0000000a      0x00000006      0x00000001
        0x401c10 <array.3294+16>:       0x0000000c      0x00000010      0x00000009      0x00000003
        0x401c20 <array.3294+32>:       0x00000004      0x00000007      0x0000000e      0x00000005
        0x401c30 <array.3294+48>:       0x0000000b      0x00000008      0x0000000f      0x0000000d

Phase_6
    In phase_6 the strtol function is used which takes a number in string from and turns it into a number in number form. This value is then put in 
        $rax. The number input is moved to 0x602e30. There are 10 nodes starting at address 0x602e30. Each node consists of 16 bytes. Therefore 
        node0 is at address 0x602e30 and node1 is at address 0x0x602e20 ... Nodes are looking to be kindof like a linked list. node has long value 
        in lower half and address of next node in upper half. 

        Some how the compliler knows that 'mov    0x8(%r8),%rdx' moves the address by 16 bytes. It must know that the offset is halfwords.

        We found that fun6 was doing lots of weird stuff ordering the linked list very strangely. At the end it compares our value we input to 
        0x12f=303. We put this value in and it worked.

Secret_Phase
    
