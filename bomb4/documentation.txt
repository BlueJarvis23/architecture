Phase_1:
    I noticed that in the phase_1 function that a value was saved in an address was saved in the 'si' register. The register was used in the string not 
        equal function so I printed out the contents of the address in the following way. 

        (gdb) x/100cb $rsi
        0x401b88:   86 'V'  101 'e' 114 'r' 98 'b'  111 'o' 115 's' 105 'i' 116 't'
        0x401b90:   121 'y' 32 ' '  108 'l' 101 'e' 97 'a'  100 'd' 115 's' 32 ' '
        0x401b98:   116 't' 111 'o' 32 ' '  117 'u' 110 'n' 99 'c'  108 'l' 101 'e'
        0x401ba0:   97 'a'  114 'r' 44 ','  32 ' '  105 'i' 110 'n' 97 'a'  114 'r'
        0x401ba8:   116 't' 105 'i' 99 'c'  117 'u' 108 'l' 97 'a'  116 't' 101 'e'
        0x401bb0:   32 ' '  116 't' 104 'h' 105 'i' 110 'n' 103 'g' 115 's' 46 '.'
        0x401bb8:   0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'
        0x401bc0:   92 '\\' 17 '\021'   64 '@'  0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'
        0x401bc8:   99 'c'  17 '\021'   64 '@'  0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'
        0x401bd0:   85 'U'  17 '\021'   64 '@'  0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'
        0x401bd8:   78 'N'  17 '\021'   64 '@'  0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'
        0x401be0:   71 'G'  17 '\021'   64 '@'  0 '\000'    0 '\000'    0 '\000'    0 '\000'    0 '\000'
        0x401be8:   64 '@'  17 '\021'   64 '@'  0 '\000'

        (gdb) x/1sb 0x401b88
        0x401b88:   "Verbosity leads to unclear, inarticulate things."
        
Phase_2
    After an accidental explosion of a bomb ('dis' will disable all breakpoints) I found that read_six_numbers just checked input from for 6 integers
        separated by a space character. If input is of this form then I arrived at instruction 0x4011d8. 

              0x00000000004011d6 <+40>:    mov    (%rbx),%eax
           => 0x00000000004011d8 <+42>:    cmp    0xc(%rbx),%eax
              0x00000000004011db <+45>:    je     0x4011e2 <phase_2+52>
              0x00000000004011dd <+47>:    callq  0x40153e <explode_bomb>

        This part is in a loop that looks at all of the numbers comparing them with the number contained in the address in rbx+0xc.

        (gdb) x $rbx +0xc 
        0x7fffffffde64: 0x00000005

        By some trial and error it was found that the sequence needed to be '3 4 5 3 4 5'

Phase_3
    After phase_2 and understanding that the instruction 'callq  0x400b28 <__isoc99_sscanf@plt>' checked for the correct number of terms to be input
        as the phase response, I learned that the sscanf function placed a value in $rax that corresponded with the number of integers found.
        This value is then compared with one less than the expected value from the function.

        0x0000000000401111 <+24>:    callq  0x400b28 <__isoc99_sscanf@plt>
        0x0000000000401116 <+29>:    cmp    $0x1,%eax

        In the case of phase_3 the input needed is 2 numbers. After an input of 2 numbers the address 0x401120 can be reached.        
