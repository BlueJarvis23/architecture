## DMarshall - A01073629
## AWallentine - A01107224

#/* $begin ncopy-ys */
##################################################################
# ncopy.ys - Copy a src block of len ints to dst.
# Return the number of positive ints (>0) contained in src.
#
# Include your name and ID here.
#  DMarshall - A01073629
#  AWallentine - A01107224
#
# Describe how and why you modified the baseline code.
# The first modification to the baseline code that we made was replacing irmovl and addl instructions with the iaddl function we wrote in part B. Using iaddl we cut down on a bubble from using the same register in sequential steps and it removed an entire instruction.
# The next modification we made was jumping to the condition code inside of the loop instead of using two extra instructions to do the check before we enter the loop.
# The next modification we made was changing the jle Npos instruction to jg, because we wanted to make the pipleline predict jumping into the loop which is the event that occurs most often. Doing this had the biggest effect on the benchmark speed, because we cutout a few instructions from the loop and made the pipeline prediction more effective.
# The next modification we made was getting rid of a bubble in the pipline by moving the mrmovl instruction. We moved this because we noticed the pipline was being delayed because eax was being written to and read in subsequent instructions.
# The last modification we made was changing count to be equal to length and subtracting instead of adding to get rid of another instruction in the loop.
##################################################################
	# Function prologue. Do not modify.
	#
	#Idea -- mmmovl
	#Idea -- use register as ofset
	#Idea -- rmmovl_4
	#Idea -- reverse condition in while so that len counts up
	#   and use len as in address computations index. (mem, len, 4) ---- Not good. 
	#   Missing cmp instruction and can not do addessing like x86 ie. D(Reg, Regs, S)
	#
ncopy:	
    pushl %ebp	        	# Save old frame pointer
	rrmovl %esp,%ebp	    # Set up new frame pointer
	pushl %esi	    	    # Save callee-save regs
	pushl %ebx
	mrmovl 8(%ebp),%ebx	    # src
	mrmovl 12(%ebp),%ecx	# dst
	mrmovl 16(%ebp),%edx	# len

	# Loop header
	#xorl %esi,%esi		    # count = 0;
	rrmovl %edx, %esi       # count = len
	jmp Middle

	# Loop body.
Loop:	
	rmmovl %eax, (%ecx)	    # ...and store it to dst
	andl %eax, %eax		    # val > 0?
	jg Ppos		            # if so, goto Ppos:
	iaddl $-1, %esi         # count++
Ppos:	
	#iaddl $1, %esi
	iaddl $-1, %edx         # len--
	iaddl $4, %ebx          # src++
	iaddl $4, %ecx          # dst++
Middle:
	andl %edx,%edx		    # len > 0?
    mrmovl (%ebx), %eax	    # read val from src...
	jg Loop			        # if so, goto Loop:

	# Function epilogue. Do not modify.
Done:	
    rrmovl %esi, %eax
	popl %ebx
	popl %esi
	rrmovl %ebp, %esp
	popl %ebp
	ret
#/* $end ncopy-ys */
